 ```solidity
function test_ETH_canBeReceivedAndRescuedByOwner() public {
    address owner = composer.owner();
    uint256 amount = 5 ether;

    // 1. Anyone can send ETH (LayerZero refunds, etc.)
    (bool sent, ) = address(composer).call{value: amount}("");
    assertTrue(sent);
    assertEq(address(composer).balance, amount);

    // 2. Owner rescues it using rescueToken(address(0), ...)
    vm.prank(owner);
    composer.rescueToken(address(0), receiver, amount);

    // Success → ETH is no longer trapped
    assertEq(address(composer).balance, 0);
    assertEq(receiver.balance, amount);
}
```

function test_ETH_cannotBeRescuedByNonOwner() public {
    // Send ETH first
    (bool sent, ) = address(composer).call{value: 1 ether}("");
    assertTrue(sent);

    // Random user tries to steal it → reverts
    vm.expectRevert("Ownable: caller is not the owner"); // or your custom error
    vm.prank(user);
    composer.rescueToken(address(0), user, 1 ether);
}

src/token/wiTRY/crosschain/wiTryVaultComposer.sol

 Contract accepts ETH via receive() but provides no mechanism to
withdraw it (trapped funds)
