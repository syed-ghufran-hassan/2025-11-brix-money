// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test} from "forge-std/Test.sol";
import {console} from "forge-std/console.sol";

// Import contracts
import {UnstakeMessenger} from "../../../src/token/wiTRY/crosschain/UnstakeMessenger.sol";
import {wiTryVaultComposer} from "../../../src/token/wiTRY/crosschain/wiTryVaultComposer.sol";
import {StakediTryComposer} from "../../../src/token/wiTRY/StakediTryComposer.sol";
import {iTrySilo} from "../../../src/token/wiTRY/iTrySilo.sol";
import {iTry} from "../../../src/token/iTRY/iTry.sol";
import {iTryTokenOFTAdapter} from "../../../src/token/iTRY/crosschain/iTryTokenOFTAdapter.sol";
import {iTryTokenOFT} from "../../../src/token/iTRY/crosschain/iTryTokenOFT.sol";
import {wiTryOFTAdapter} from "../../../src/token/wiTRY/crosschain/wiTryOFTAdapter.sol";
import {wiTryOFT} from "../../../src/token/wiTRY/crosschain/wiTryOFT.sol";

// Import LayerZero interfaces
import {Origin} from "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppReceiver.sol";
import {IOAppCore} from "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppCore.sol";
import {MessagingFee} from "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppSender.sol";
import {SendParam} from "@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/**
 * @title CrosschainUnstakeIntegrationTest
 * @notice Integration tests for the complete crosschain unstaking flow
 * @dev Tests the full flow: Spoke → Hub → Spoke
 *      - UnstakeMessenger on spoke chain initiates unstake request
 *      - VaultComposer on hub chain processes unstake and clears cooldown
 *      - iTRY is sent back to user on spoke chain
 *
 * NOTE: This test uses mocks for LayerZero endpoints and simulates message passing
 *       For full end-to-end testing, use fork tests with real LayerZero infrastructure
 */
contract CrosschainUnstakeIntegrationTest is Test {
    // ============ STATE VARIABLES ============

    // Spoke chain contracts
    UnstakeMessenger public unstakeMessenger;
    iTryTokenOFT public spokeITryOFT;
    wiTryOFT public spokeShareOFT;

    // Hub chain contracts
    wiTryVaultComposer public vaultComposer;
    StakediTryComposer public vault;
    iTrySilo public silo;
    iTry public hubITry;
    iTryTokenOFTAdapter public iTryAdapter;
    wiTryOFTAdapter public shareAdapter;

    // Test accounts
    address public deployer;
    address public userA;
    address public userB;
    address public userC;

    // Mock endpoints
    MockLayerZeroEndpoint public spokeEndpoint;
    MockLayerZeroEndpoint public hubEndpoint;

    // Chain constants
    uint32 public constant SPOKE_EID = 40232; // OP Sepolia
    uint32 public constant HUB_EID = 40161;   // Sepolia

    // Test constants
    uint256 public constant COOLDOWN_DURATION = 3 days;
    uint256 public constant TEST_AMOUNT = 100 ether;
    uint256 public constant SMALL_AMOUNT = 1 wei;
    uint256 public constant LARGE_AMOUNT = 1_000_000 ether;

    // ============ EVENTS ============

    event UnstakeRequested(address indexed user, uint32 indexed hubEid, uint256 nativeFee, bytes32 guid);
    event CrosschainUnstakeProcessed(address indexed user, uint32 indexed srcEid, uint256 assets, bytes32 guid);
    event CrosschainUnstakeFailed(address indexed user, uint32 indexed srcEid, string reason);

    // ============ SETUP ============

    function setUp() public {
        deployer = makeAddr("deployer");
        userA = makeAddr("userA");
        userB = makeAddr("userB");
        userC = makeAddr("userC");

        vm.startPrank(deployer);

        // Deploy mock endpoints
        spokeEndpoint = new MockLayerZeroEndpoint(SPOKE_EID);
        hubEndpoint = new MockLayerZeroEndpoint(HUB_EID);

        // Deploy hub chain contracts
        _deployHubContracts();

        // Deploy spoke chain contracts
        _deploySpokeContracts();

        // Configure relationships
        _configurePeers();
        _setupRoles();
        _fundAccounts();

        vm.stopPrank();
    }

    function _deployHubContracts() private {
        // Deploy iTRY token (upgradeable - using direct deployment for testing)
        hubITry = new iTry();
        hubITry.initialize(deployer, deployer);

        // Deploy vault (will create iTrySilo internally)
        vault = new StakediTryComposer(
            IERC20(address(hubITry)),
            deployer, // initialRewarder
            deployer, // owner
            deployer  // fastRedeemTreasury
        );

        // Get the silo from vault
        silo = iTrySilo(address(vault.silo()));

        // Deploy adapters
        iTryAdapter = new iTryTokenOFTAdapter(
            address(hubITry),
            address(hubEndpoint),
            deployer
        );

        shareAdapter = new wiTryOFTAdapter(
            address(vault),
            address(hubEndpoint),
            deployer
        );

        // Deploy wiTryVaultComposer (includes OApp functionality)
        vaultComposer = new wiTryVaultComposer(
            address(vault),
            address(iTryAdapter),
            address(shareAdapter),
            address(hubEndpoint)
        );

        // Configure vault settings
        vault.setCooldownDuration(uint24(COOLDOWN_DURATION));

        console.log("Hub contracts deployed:");
        console.log("  iTryToken:", address(hubITry));
        console.log("  Vault:", address(vault));
        console.log("  Silo:", address(silo));
        console.log("  iTryAdapter:", address(iTryAdapter));
        console.log("  VaultComposer:", address(vaultComposer));
    }

    function _deploySpokeContracts() private {
        // Deploy iTryTokenOFT
        spokeITryOFT = new iTryTokenOFT(
            address(spokeEndpoint),
            deployer
        );

        // Deploy wiTryOFT
        spokeShareOFT = new wiTryOFT(
            address(spokeEndpoint),
            deployer
        );

        // Deploy UnstakeMessenger
        unstakeMessenger = new UnstakeMessenger(
            address(spokeEndpoint),
            deployer,
            HUB_EID
        );

        console.log("Spoke contracts deployed:");
        console.log("  iTryTokenOFT:", address(spokeITryOFT));
        console.log("  ShareOFT:", address(spokeShareOFT));
        console.log("  UnstakeMessenger:", address(unstakeMessenger));
    }

    function _configurePeers() private {
        // Set UnstakeMessenger peer to VaultComposer
        unstakeMessenger.setPeer(
            HUB_EID,
            bytes32(uint256(uint160(address(vaultComposer))))
        );

        // Set VaultComposer peer to UnstakeMessenger
        vaultComposer.setPeer(
            SPOKE_EID,
            bytes32(uint256(uint160(address(unstakeMessenger))))
        );

        // Set iTry OFT peers
        spokeITryOFT.setPeer(
            HUB_EID,
            bytes32(uint256(uint160(address(iTryAdapter))))
        );
        iTryAdapter.setPeer(
            SPOKE_EID,
            bytes32(uint256(uint160(address(spokeITryOFT))))
        );

        // Set Share OFT peers
        spokeShareOFT.setPeer(
            HUB_EID,
            bytes32(uint256(uint160(address(shareAdapter))))
        );
        shareAdapter.setPeer(
            SPOKE_EID,
            bytes32(uint256(uint160(address(spokeShareOFT))))
        );

        console.log("Peers configured successfully");
    }

    function _setupRoles() private {
        // Grant COMPOSER_ROLE to VaultComposer
        bytes32 composerRole = vault.COMPOSER_ROLE();
        vault.grantRole(composerRole, address(vaultComposer));

        // iTryToken doesn't use roles - owner can mint directly
        // No additional role setup needed for iTryToken

        console.log("Roles configured successfully");
    }

    function _fundAccounts() private {
        // Fund users with ETH for gas
        vm.deal(userA, 10 ether);
        vm.deal(userB, 10 ether);
        vm.deal(userC, 10 ether);

        // Mint iTRY to hub for testing
        hubITry.mint(address(silo), 10_000_000 ether);

        console.log("Accounts funded successfully");
    }

    // ============ HELPER FUNCTIONS ============

    /**
     * @notice Simulate cooldown initiation on hub chain
     * @dev In real scenario, this would come via crosschain message
     */
    function _simulateInitiateCooldown(address user, uint256 shares) private {
        // Mint shares to VaultComposer (simulating bridged shares)
        // Need to deposit iTRY first to get shares
        vm.startPrank(deployer);

        // Mint iTRY to vault for deposit
        hubITry.mint(deployer, shares);
        hubITry.approve(address(vault), shares);

        // Deposit to get shares, then transfer to composer
        uint256 shareAmount = vault.deposit(shares, address(vaultComposer));

        vm.stopPrank();

        // Initiate cooldown via VaultComposer using shares
        vm.prank(address(vaultComposer));
        vault.cooldownSharesByComposer(shareAmount, user);

        console.log("Cooldown initiated for user:", user);
        console.log("  Shares:", shareAmount);
    }

    /**
     * @notice Simulate UnstakeMessenger sending message to VaultComposer
     * @dev Manually calls VaultComposer._lzReceive to simulate LayerZero message delivery
     */
    function _simulateUnstakeMessage(address user) private returns (bytes32 guid) {
        // Build UnstakeMessage payload
        bytes memory extraOptions = "";
        bytes memory message = abi.encode(user, extraOptions);
        bytes memory payload = abi.encode(uint16(1), message); // MSG_TYPE_UNSTAKE = 1

        // Generate guid
        guid = keccak256(abi.encodePacked(SPOKE_EID, user, block.timestamp));

        // Build Origin struct
        Origin memory origin = Origin({
            srcEid: SPOKE_EID,
            sender: bytes32(uint256(uint160(address(unstakeMessenger)))),
            nonce: uint64(block.timestamp)
        });

        // Call _lzReceive on VaultComposer
        vm.prank(address(hubEndpoint));
        vaultComposer.lzReceive(
            origin,
            guid,
            payload,
            address(0), // executor
            "" // extraData
        );

        return guid;
    }

    /**
     * @notice Simulate iTRY return message to spoke chain
     * @dev Manually mints iTRY on spoke to simulate LayerZero OFT transfer
     */
    function _simulateITryReturn(address user, uint256 amount) private {
        // In real scenario, LayerZero would deliver message and mint tokens
        // For testing, we directly mint to user
        vm.prank(address(spokeITryOFT));
        // Mock the mint by tracking balance (spokeITryOFT doesn't have direct mint)
        // Instead, we'll check that the flow would trigger this
        console.log("Simulated iTRY return to user:", user);
        console.log("  Amount:", amount);
    }

    // ============ INTEGRATION TESTS ============

    /**
     * @notice Test 1: Happy Path - Full crosschain unstake flow
     * @dev Tests complete flow from cooldown initiation to unstake completion
     */
    function test_HappyPath_FullCrosschainUnstake() public {
        console.log("\n=== TEST: Happy Path - Full Crosschain Unstake ===");

        // 1. Setup: Initiate cooldown on hub
        console.log("\nStep 1: Initiating cooldown on hub...");
        _simulateInitiateCooldown(userA, TEST_AMOUNT);

        // Verify cooldown initiated
        (uint104 cooldownEnd, uint256 underlyingAmount) = vault.cooldowns(userA);
        assertGt(cooldownEnd, 0, "Cooldown should be initiated");
        assertEq(underlyingAmount, TEST_AMOUNT, "Cooldown amount should match");
        console.log("  Cooldown end:", cooldownEnd);
        console.log("  Cooldown amount:", underlyingAmount);

        // 2. Fast-forward past cooldown period
        console.log("\nStep 2: Fast-forwarding past cooldown period...");
        vm.warp(block.timestamp + COOLDOWN_DURATION + 1);
        console.log("  New timestamp:", block.timestamp);

        // 3. User calls unstake on spoke chain
        console.log("\nStep 3: User calling unstake on spoke...");
        vm.prank(userA);
        vm.expectEmit(true, true, false, false, address(unstakeMessenger));
        emit UnstakeRequested(userA, HUB_EID, 0, bytes32(0));
        bytes32 guid = unstakeMessenger.unstake{value: 0.01 ether}();
        console.log("  Unstake requested, guid:", uint256(guid));

        // 4. Simulate message delivery to hub
        console.log("\nStep 4: Simulating message delivery to hub...");
        vm.expectEmit(true, true, false, false, address(vaultComposer));
        emit CrosschainUnstakeProcessed(userA, SPOKE_EID, TEST_AMOUNT, bytes32(0));
        bytes32 processGuid = _simulateUnstakeMessage(userA);
        console.log("  Message processed, guid:", uint256(processGuid));

        // 5. Verify cooldown cleared
        console.log("\nStep 5: Verifying cooldown cleared...");
        (uint104 cooldownEndAfter, uint256 underlyingAmountAfter) = vault.cooldowns(userA);
        assertEq(cooldownEndAfter, 0, "Cooldown should be cleared");
        assertEq(underlyingAmountAfter, 0, "Cooldown amount should be zero");
        console.log("  Cooldown cleared successfully");

        // 6. Verify iTRY would be sent back (simulated)
        console.log("\nStep 6: Verifying iTRY return flow...");
        _simulateITryReturn(userA, TEST_AMOUNT);

        console.log("\n=== TEST PASSED: Happy Path ===\n");
    }

    /**
     * @notice Test 2: Error Scenario - Cooldown Not Ready
     * @dev Tests that unstake reverts when cooldown period not complete
     */
    function test_Error_CooldownNotReady() public {
        console.log("\n=== TEST: Error - Cooldown Not Ready ===");

        // 1. Setup: Initiate cooldown on hub
        console.log("\nStep 1: Initiating cooldown on hub...");
        _simulateInitiateCooldown(userA, TEST_AMOUNT);

        // 2. Try to unstake BEFORE cooldown complete (no time warp)
        console.log("\nStep 2: Attempting unstake before cooldown ready...");
        vm.prank(userA);
        bytes32 guid = unstakeMessenger.unstake{value: 0.01 ether}();

        // 3. Simulate message delivery - should emit CrosschainUnstakeFailed
        console.log("\nStep 3: Simulating message delivery...");
        vm.expectEmit(true, true, false, true, address(vaultComposer));
        emit CrosschainUnstakeFailed(userA, SPOKE_EID, "Cooldown not ready");

        // This should fail inside _lzReceive
        vm.expectRevert(); // Will revert with CooldownNotReady
        _simulateUnstakeMessage(userA);

        // 4. Verify cooldown NOT cleared
        console.log("\nStep 4: Verifying cooldown not cleared...");
        (uint104 cooldownEnd, uint256 underlyingAmount) = vault.cooldowns(userA);
        assertGt(cooldownEnd, 0, "Cooldown should still exist");
        assertEq(underlyingAmount, TEST_AMOUNT, "Cooldown amount should be unchanged");

        console.log("\n=== TEST PASSED: Cooldown Not Ready ===\n");
    }

    /**
     * @notice Test 3: Error Scenario - No Cooldown Found
     * @dev Tests that unstake reverts when user has no cooldown
     */
    function test_Error_NoCooldownFound() public {
        console.log("\n=== TEST: Error - No Cooldown Found ===");

        // 1. User calls unstake WITHOUT initiating cooldown
        console.log("\nStep 1: User calling unstake without cooldown...");
        vm.prank(userA);
        bytes32 guid = unstakeMessenger.unstake{value: 0.01 ether}();

        // 2. Simulate message delivery - should revert with NoCooldownFound
        console.log("\nStep 2: Simulating message delivery...");
        vm.expectRevert(); // Will revert with NoCooldownFound
        _simulateUnstakeMessage(userA);

        // 3. Verify no cooldown exists
        console.log("\nStep 3: Verifying no cooldown exists...");
        (uint104 cooldownEnd, uint256 underlyingAmount) = vault.cooldowns(userA);
        assertEq(cooldownEnd, 0, "No cooldown should exist");
        assertEq(underlyingAmount, 0, "Cooldown amount should be zero");

        console.log("\n=== TEST PASSED: No Cooldown Found ===\n");
    }

    /**
     * @notice Test 4: Multi-User Test
     * @dev Tests that three users can unstake independently without cross-contamination
     */
    function test_MultiUser_ThreeUsersUnstakeIndependently() public {
        console.log("\n=== TEST: Multi-User - Three Users Unstake Independently ===");

        // 1. Setup: All three users initiate cooldowns with different amounts
        console.log("\nStep 1: Initiating cooldowns for all users...");
        uint256 amountA = 100 ether;
        uint256 amountB = 200 ether;
        uint256 amountC = 300 ether;

        _simulateInitiateCooldown(userA, amountA);
        _simulateInitiateCooldown(userB, amountB);
        _simulateInitiateCooldown(userC, amountC);

        // Verify all cooldowns initiated
        (uint104 cooldownEndA, uint256 underlyingAmountA) = vault.cooldowns(userA);
        (uint104 cooldownEndB, uint256 underlyingAmountB) = vault.cooldowns(userB);
        (uint104 cooldownEndC, uint256 underlyingAmountC) = vault.cooldowns(userC);

        assertGt(cooldownEndA, 0, "User A cooldown should be initiated");
        assertGt(cooldownEndB, 0, "User B cooldown should be initiated");
        assertGt(cooldownEndC, 0, "User C cooldown should be initiated");

        // 2. Fast-forward past cooldown period
        console.log("\nStep 2: Fast-forwarding past cooldown period...");
        vm.warp(block.timestamp + COOLDOWN_DURATION + 1);

        // 3. Users unstake in different order: B, A, C
        console.log("\nStep 3: Users unstaking in order: B, A, C...");

        // User B unstakes
        console.log("\n  User B unstaking...");
        vm.prank(userB);
        unstakeMessenger.unstake{value: 0.01 ether}();
        _simulateUnstakeMessage(userB);

        (uint104 cooldownEndB_after, uint256 underlyingAmountB_after) = vault.cooldowns(userB);
        assertEq(cooldownEndB_after, 0, "User B cooldown should be cleared");
        assertEq(underlyingAmountB_after, 0, "User B cooldown amount should be zero");

        // Verify A and C cooldowns still exist
        (uint104 cooldownEndA_check1, uint256 underlyingAmountA_check1) = vault.cooldowns(userA);
        (uint104 cooldownEndC_check1, uint256 underlyingAmountC_check1) = vault.cooldowns(userC);
        assertGt(cooldownEndA_check1, 0, "User A cooldown should still exist");
        assertGt(cooldownEndC_check1, 0, "User C cooldown should still exist");
        assertEq(underlyingAmountA_check1, amountA, "User A amount unchanged");
        assertEq(underlyingAmountC_check1, amountC, "User C amount unchanged");

        // User A unstakes
        console.log("\n  User A unstaking...");
        vm.prank(userA);
        unstakeMessenger.unstake{value: 0.01 ether}();
        _simulateUnstakeMessage(userA);

        (uint104 cooldownEndA_after, uint256 underlyingAmountA_after) = vault.cooldowns(userA);
        assertEq(cooldownEndA_after, 0, "User A cooldown should be cleared");
        assertEq(underlyingAmountA_after, 0, "User A cooldown amount should be zero");

        // Verify C cooldown still exists
        (uint104 cooldownEndC_check2, uint256 underlyingAmountC_check2) = vault.cooldowns(userC);
        assertGt(cooldownEndC_check2, 0, "User C cooldown should still exist");
        assertEq(underlyingAmountC_check2, amountC, "User C amount unchanged");

        // User C unstakes
        console.log("\n  User C unstaking...");
        vm.prank(userC);
        unstakeMessenger.unstake{value: 0.01 ether}();
        _simulateUnstakeMessage(userC);

        (uint104 cooldownEndC_after, uint256 underlyingAmountC_after) = vault.cooldowns(userC);
        assertEq(cooldownEndC_after, 0, "User C cooldown should be cleared");
        assertEq(underlyingAmountC_after, 0, "User C cooldown amount should be zero");

        console.log("\n=== TEST PASSED: Multi-User Test ===\n");
    }

    /**
     * @notice Test 5: Edge Cases - Zero, Small, Large Amounts
     * @dev Tests edge case scenarios with different amounts
     */
    function test_EdgeCases_ZeroSmallLargeAmounts() public {
        console.log("\n=== TEST: Edge Cases - Zero, Small, Large Amounts ===");

        // Test 1: Very small amount (1 wei)
        console.log("\nTest 1: Very small amount (1 wei)...");
        _simulateInitiateCooldown(userA, SMALL_AMOUNT);
        vm.warp(block.timestamp + COOLDOWN_DURATION + 1);

        vm.prank(userA);
        unstakeMessenger.unstake{value: 0.01 ether}();
        _simulateUnstakeMessage(userA);

        (uint104 cooldownEndA, uint256 underlyingAmountA) = vault.cooldowns(userA);
        assertEq(cooldownEndA, 0, "Small amount cooldown should be cleared");
        assertEq(underlyingAmountA, 0, "Small amount cooldown amount should be zero");

        // Test 2: Very large amount
        console.log("\nTest 2: Very large amount (1M ether)...");
        vm.warp(block.timestamp + 1); // Move time forward for new cooldown
        _simulateInitiateCooldown(userB, LARGE_AMOUNT);
        vm.warp(block.timestamp + COOLDOWN_DURATION + 1);

        vm.prank(userB);
        unstakeMessenger.unstake{value: 0.01 ether}();
        _simulateUnstakeMessage(userB);

        (uint104 cooldownEndB, uint256 underlyingAmountB) = vault.cooldowns(userB);
        assertEq(cooldownEndB, 0, "Large amount cooldown should be cleared");
        assertEq(underlyingAmountB, 0, "Large amount cooldown amount should be zero");

        // Test 3: Sequential unstakes (cooldown → unstake → cooldown → unstake)
        console.log("\nTest 3: Sequential unstakes...");

        // First unstake
        vm.warp(block.timestamp + 1);
        _simulateInitiateCooldown(userC, TEST_AMOUNT);
        vm.warp(block.timestamp + COOLDOWN_DURATION + 1);
        vm.prank(userC);
        unstakeMessenger.unstake{value: 0.01 ether}();
        _simulateUnstakeMessage(userC);

        (uint104 cooldownEndC1, uint256 underlyingAmountC1) = vault.cooldowns(userC);
        assertEq(cooldownEndC1, 0, "First cooldown should be cleared");

        // Second unstake
        vm.warp(block.timestamp + 1);
        _simulateInitiateCooldown(userC, TEST_AMOUNT * 2);
        vm.warp(block.timestamp + COOLDOWN_DURATION + 1);
        vm.prank(userC);
        unstakeMessenger.unstake{value: 0.01 ether}();
        _simulateUnstakeMessage(userC);

        (uint104 cooldownEndC2, uint256 underlyingAmountC2) = vault.cooldowns(userC);
        assertEq(cooldownEndC2, 0, "Second cooldown should be cleared");

        console.log("\n=== TEST PASSED: Edge Cases ===\n");
    }
}

/**
 * @title MockLayerZeroEndpoint
 * @notice Minimal mock of LayerZero endpoint for integration testing
 */
contract MockLayerZeroEndpoint {
    uint32 public immutable eid;

    constructor(uint32 _eid) {
        eid = _eid;
    }

    function setDelegate(address /*_delegate*/) external {
        // No-op for testing
    }

    function quote(
        address /*_sender*/,
        uint32 /*_dstEid*/,
        bytes calldata /*_message*/,
        bytes calldata /*_options*/,
        bool /*_payInLzToken*/
    ) external pure returns (MessagingFee memory) {
        return MessagingFee(0.001 ether, 0);
    }

    function send(
        address /*_sender*/,
        uint32 /*_dstEid*/,
        bytes calldata /*_message*/,
        bytes calldata /*_options*/,
        MessagingFee calldata /*_fee*/,
        address /*_refundAddress*/
    ) external payable returns (bytes32) {
        return keccak256(abi.encodePacked(block.timestamp, msg.sender));
    }
}
